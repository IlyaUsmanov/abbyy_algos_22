Будем решать задачу при помощи ДП. Рассмотрим все суммы, которые мы можем набрать при помощи [coin_1] это будут [0, coin_1, coin_1 * 2, ...], при помощи [coin_1, coin_2] мы сможем набрать уже суммы вида: то, что удалось набрать при помощи только coin_1 + coin_2 * k, значит на i-м шаге, применяя такое же рассуждение, будет верно, что мы можем набрать суммы вида: то, что удалось на предыдущем шаге + coin_i * k. Преобразуем эти рассуждения в алгоритм: dp[i][j] = {можем ли набрать j при помощи первых i монет}, тогда чтобы получить dp[i+1][:] будем перебирать коэффициент k перед coin_i+1 и перебирать j, и для такой пары обновлять dp[i+1][j+(coin_i+1) * k] |= dp[i][j]. И как и в предыдущей задаче можем вместо матрицы хранить только последний слой
