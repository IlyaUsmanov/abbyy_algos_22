Используем классический алгоритм поиска мостов в графе: обойдем граф dfs-ом, тогда ребра не попавшие в дерево обхода, понятно, не будут мостами, а для попавших проверим,
что из дочерней вершины нет пути в ее предков(это работает, потому что все ребра графа либо принадлежат дереву обхода, либо ведут от потомков к предкам в этом дереве)
для каждой вершины v запишем tin[v] - время входа в нее при dfs-е и fup[v] = min(tin[v]; fup[u], u - дочерняя; tin[u], u - предок), тогда для ребра u->v, если есть путь
из v в ее предка, fup[v] будет равен tin этого самого предка => fup[v] <= tin[u], иначе, fup[v] будет равен tin[v] > tin[u]. Значит, критерием того, что ребро - мост,
будем считать fup[v] > tin[u]
